This compiler is a project for Case Western Reserve University's 
EECS 337 course (Compiler Design).
By John Gunderman

The parser is not yet part of the test suite. Not much is, really.
Anyway, compiling the parser is as easy as a 'make -B parser', and
running it is as easy as a './parser'.

The test suite can be compiled by running 'make test'. It will create
the './test_suite' executable, which can then be run.


So, you may notice that, while everything works well in the code for
Hmwk 5, there is a definite lack of test cases. This is largely due to
the fact that it is 3 in the morning, and I'm not feeling particularly
friendly towards test driven development. Fortunately, this code isn't
going into production, so the lack of test cases won't cause customers
to suffer. Unfortunately, it may cause my grade to suffer. If so, I 
would ask that the TA have pity on my soul and only dock me a few points.

If it counts for anything, my output is pretty :D

Locations of variables are printed out when the symbol table gets printed out.

KNOWN PROBLEM:
If-else statements aren't working due to an unfortunate glitch in bison that I
don't know how to fix. Yet. Everything else is working like magic though,
including standard 'if' statements.


Error Handing:
=============
Error handling in this parser is quite simple: don't type it wrong.
The parser isn't gonna give you much info besides "syntax error".
If you're perfect, this isn't a problem, if you aren't perfect,
remember that I'm not either (or I am perfect, but I don't have time
to spare). I'll get around to adding line number error handling
at some point, but at least yacc tells you that you have a problem.
Strategy: Do it right the first time.

UPDATE: you may get a segfault if you try and treat a number as a boolean
or vice versa.


NOTE:
=====
Currently, there is not type checking for booleans being used with
ints/floats because I am just going to translate all booleans into
an integer with value 1 or 0, which avoids the issue.

Also, implicit widening does not occur in the given test program,
but it can be shown to work by adding the line

x = i + v;

to the end of the main block.



TEST PROGRAM:

{
  int i; int j; float v; float x; float[100] a;
  while (true) {
    do i = i+1; while(a[i] < v);
    do j = j-1; while(a[j] > v);
    if(i >= j) break;
    x = a[i]; a[i] = a[j]; a[j] = x;
  }
}


OUTPUT:

decls->empty
type-> BASIC 
decl-> type ID
decls->decls decl
type-> BASIC 
decl-> type ID
decls->decls decl
type-> BASIC 
decl-> type ID
decls->decls decl
type-> BASIC 
decl-> type ID
decls->decls decl
type-> BASIC 
type-> type [ NUM ]
decl-> type ID
decls->decls decl
stmts->empty
getting next instruction...
getting next instruction...
factor->TRUE
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
getting next instruction...


Entering New Scope

decls->empty
stmts->empty
getting next instruction...
getting next instruction...
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
factor->NUM
urnary->factor
term->urnary
expr->expr + expr
rel->expr
equality->rel
join->equality
bool->join
stmt->loc = bool
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
loc-> loc [ bool ]
factor->loc
urnary->factor
term->urnary
expr->term
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr < expr
equality->rel
join->equality
bool->join
stmt->DO stmt WHILE ( bool ) ;
stmts->stmts stmt
getting next instruction...
getting next instruction...
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
factor->NUM
urnary->factor
term->urnary
expr->expr - expr
rel->expr
equality->rel
join->equality
bool->join
stmt->loc = bool
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
loc-> loc [ bool ]
factor->loc
urnary->factor
term->urnary
expr->term
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr > expr
equality->rel
join->equality
bool->join
stmt->DO stmt WHILE ( bool ) ;
stmts->stmts stmt
getting next instruction...
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr >= expr
equality->rel
join->equality
bool->join
getting next instruction...
getting next instruction...
stmt->BREAK ;
stmt->IF ( bool ) stmt
stmts->stmts stmt
getting next instruction...
loc->ID
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
loc-> loc [ bool ]
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
stmt->loc = bool
stmts->stmts stmt
getting next instruction...
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
loc-> loc [ bool ]
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
loc-> loc [ bool ]
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
stmt->loc = bool
stmts->stmts stmt
getting next instruction...
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
loc-> loc [ bool ]
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
stmt->loc = bool
stmts->stmts stmt
block->decls stmts
stmt->block


Leaving Scope

stmt->WHILE ( bool ) stmt
stmts->stmts stmt
block->decls stmts


Environment Table (Top - 0)
Key: i
Value: {loc=0, &int_var,0,0,NULL,NULL}

Key: j
Value: {loc=4, &int_var,0,0,NULL,NULL}

Key: v
Value: {loc=8, &float_var,0,0,NULL,NULL}

Key: x
Value: {loc=12, &float_var,0,0,NULL,NULL}

Key: a
Value: {loc=16, &float_var,1,100,{loc=16, &float_var,0,0,NULL,0x8ba4538},NULL}

Intermediate Code:
Op	Arg1		Arg2		Result
goto					Code: 0x804d47d	
+	Symbol: i	Symbol: @1	Symbol: @2	
=	Symbol: @2			Symbol: i	
<	Symbol: a	Symbol: v	Code: 0x804d47d	
goto					Code: 0x804d491	
-	Symbol: j	Symbol: @4	Symbol: @5	
=	Symbol: @5			Symbol: j	
>	Symbol: a	Symbol: v	Code: 0x804d491	
goto					Code: 0x804d44b	
>=	Symbol: i	Symbol: j	Code: 0x804d284	
goto					Code: 0x804d251	
goto					Code: 0x804d251	
=	Symbol: a			Symbol: x	
=	Symbol: a			Symbol: a	
=	Symbol: x			Symbol: a	
goto					Code: 0x804d284	