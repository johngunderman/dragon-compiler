This compiler is a project for Case Western Reserve University's 
EECS 337 course (Compiler Design).
By John Gunderman

The parser is not yet part of the test suite. Not much is, really.
Anyway, compiling the parser is as easy as a 'make -B parser', and
running it is as easy as a './parser'.

The test suite can be compiled by running 'make test'. It will create
the './test_suite' executable, which can then be run. What is and 
is not covered by the test suite tends to vary.


Error Handing:
=============
Error handling in this parser is quite simple: don't type it wrong.
The parser isn't gonna give you much info besides "syntax error".
If you're perfect, this isn't a problem, if you aren't perfect,
remember that I'm not either (or I am perfect, but I don't have time
to spare). I'll get around to adding line number error handling
at some point, but at least yacc tells you that you have a problem.
Strategy: Do it right the first time.


NOTE:
=====
Type conversion and type checking are virtually non-existent.
Type-checking might work, but there's not type conversion there
as of yet. This is mainly due to the fact that the 337 due dates
almost always correspond with my Chem exams...

One last note, the symbol table currently prints out funky symbols
for some of the args. I'm not sure what the deal is atm, but I'll
get it resolved by the next homework.


TEST PROGRAM:

{
  int i; int j; float v; float x; float[100] a;
  while (true) {
    do i = i+1; while(a[i] < v);
    do j = j-1; while(a[j] > v);
    if(i >= j) break;
    x = a[i]; a[i] = a[j]; a[j] = x;
  }
}


OUTPUT:

decls->empty
type-> BASIC 
decl-> type ID
decls->decls decl
type-> BASIC 
decl-> type ID
decls->decls decl
type-> BASIC 
decl-> type ID
decls->decls decl
type-> BASIC 
decl-> type ID
decls->decls decl
type-> BASIC 
type-> type [ NUM ]
decl-> type ID
decls->decls decl
stmts->empty
factor->TRUE
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
decls->empty
stmts->empty
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
factor->NUM
urnary->factor
term->urnary
expr->expr + expr
rel->expr
equality->rel
join->equality
bool->join
stmt->loc = bool
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
loc-> loc [ bool ]
factor->loc
urnary->factor
term->urnary
expr->term
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr < expr
equality->rel
join->equality
bool->join
stmt->DO stmt WHILE ( bool ) ;
stmts->stmts stmt
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
factor->NUM
urnary->factor
term->urnary
expr->expr - expr
rel->expr
equality->rel
join->equality
bool->join
stmt->loc = bool
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
loc-> loc [ bool ]
factor->loc
urnary->factor
term->urnary
expr->term
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr > expr
equality->rel
join->equality
bool->join
stmt->DO stmt WHILE ( bool ) ;
stmts->stmts stmt
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr >= expr
equality->rel
join->equality
bool->join
stmt->BREAK ;
stmt->IF ( bool ) stmt
stmts->stmts stmt
loc->ID
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
loc-> loc [ bool ]
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
stmt->loc = bool
stmts->stmts stmt
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
loc-> loc [ bool ]
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
loc-> loc [ bool ]
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
stmt->loc = bool
stmts->stmts stmt
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
loc-> loc [ bool ]
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
stmt->loc = bool
stmts->stmts stmt
block->decls stmts
stmt->block
stmt->WHILE ( bool ) stmt
stmts->stmts stmt
block->decls stmts


Key: @4
Value: {unknown_type,0,0,NULL,NULL}

Key: @5
Value: {&int_var,0,0,NULL,NULL}

Key: @6
Value: {unknown_type,0,0,NULL,NULL}

Key: @7
Value: {unknown_type,0,0,NULL,NULL}

Key: @8
Value: {unknown_type,0,0,NULL,NULL}

Key: i
Value: {&int_var,0,0,NULL,NULL}

Key: j
Value: {&int_var,0,0,NULL,NULL}

Key: v
Value: {&float_var,0,0,NULL,NULL}

Key: x
Value: {&float_var,0,0,NULL,NULL}

Key: @1
Value: {&true_var,0,0,NULL,NULL}

Key: a
Value: {&float_var,1,100,{&float_var,0,0,NULL,0x9e4d510},NULL}

Key: @2
Value: {&int_var,0,0,NULL,NULL}

Key: @3
Value: {unknown_type,0,0,NULL,NULL}

Intermediate Code:
Op	Arg1		Arg2		Result
OP: +	Symbol: 	Symbol: @2	Symbol: @3	
OP: =	Symbol: @3			Symbol: 	
OP: <=	Symbol: 	Symbol: 	Symbol: @4	
OP: -	Symbol: 	Symbol: @5	Symbol: @6	
OP: =	Symbol: @6			Symbol: 	
OP: >	Symbol: 	Symbol: 	Symbol: @7	
OP: >=	Symbol: 	Symbol: 	Symbol: @8	
OP: =	Symbol: 			Symbol: 	
OP: =	Symbol: 			Symbol: 	
OP: =	Symbol: 			Symbol: 	