This compiler is a project for Case Western Reserve University's 
EECS 337 course (Compiler Design).
By John Gunderman

The parser is not yet part of the test suite. Not much is, really.
Anyway, compiling the parser is as easy as a 'make -B parser', and
running it is as easy as a './parser'.

The test suite can be compiled by running 'make test'. It will create
the './test_suite' executable, which can then be run.


Error Handing:
=============
Error handling in this parser is quite simple: don't type it wrong.
The parser isn't gonna give you much info besides "syntax error".
If you're perfect, this isn't a problem, if you aren't perfect,
remember that I'm not either (or I am perfect, but I don't have time
to spare). I'll get around to adding line number error handling
at some point, but at least yacc tells you that you have a problem.
Strategy: Do it right the first time.


NOTE:
=====
Currently, there is not type checking for booleans being used with
ints/floats because I am just going to translate all booleans into
an integer with value 1 or 0, which avoids the issue.

Also, implicit widening does not occur in the given test program,
but it can be shown to work by adding the line

x = i + v;

to the end of the main block.



TEST PROGRAM:

{
  int i; int j; float v; float x; float[100] a;
  while (true) {
    do i = i+1; while(a[i] < v);
    do j = j-1; while(a[j] > v);
    if(i >= j) break;
    x = a[i]; a[i] = a[j]; a[j] = x;
  }
}


OUTPUT:

decls->empty
type-> BASIC 
decl-> type ID
decls->decls decl
type-> BASIC 
decl-> type ID
decls->decls decl
type-> BASIC 
decl-> type ID
decls->decls decl
type-> BASIC 
decl-> type ID
decls->decls decl
type-> BASIC 
type-> type [ NUM ]
decl-> type ID
decls->decls decl
stmts->empty
factor->TRUE
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
decls->empty
stmts->empty
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
factor->NUM
urnary->factor
term->urnary
expr->expr + expr
rel->expr
equality->rel
join->equality
bool->join
stmt->loc = bool
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
loc-> loc [ bool ]
factor->loc
urnary->factor
term->urnary
expr->term
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr < expr
equality->rel
join->equality
bool->join
stmt->DO stmt WHILE ( bool ) ;
stmts->stmts stmt
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
factor->NUM
urnary->factor
term->urnary
expr->expr - expr
rel->expr
equality->rel
join->equality
bool->join
stmt->loc = bool
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
loc-> loc [ bool ]
factor->loc
urnary->factor
term->urnary
expr->term
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr > expr
equality->rel
join->equality
bool->join
stmt->DO stmt WHILE ( bool ) ;
stmts->stmts stmt
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr >= expr
equality->rel
join->equality
bool->join
stmt->BREAK ;
stmt->IF ( bool ) stmt
stmts->stmts stmt
loc->ID
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
loc-> loc [ bool ]
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
stmt->loc = bool
stmts->stmts stmt
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
loc-> loc [ bool ]
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
loc-> loc [ bool ]
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
stmt->loc = bool
stmts->stmts stmt
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
loc-> loc [ bool ]
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
stmt->loc = bool
stmts->stmts stmt
block->decls stmts
stmt->block
stmt->WHILE ( bool ) stmt
stmts->stmts stmt
block->decls stmts


Key: @4
Value: {unknown_type,0,0,NULL,NULL}

Key: @5
Value: {&int_var,0,0,NULL,NULL}

Key: @6
Value: {unknown_type,0,0,NULL,NULL}

Key: @7
Value: {unknown_type,0,0,NULL,NULL}

Key: @8
Value: {unknown_type,0,0,NULL,NULL}

Key: i
Value: {&int_var,0,0,NULL,NULL}

Key: j
Value: {&int_var,0,0,NULL,NULL}

Key: v
Value: {&float_var,0,0,NULL,NULL}

Key: x
Value: {&float_var,0,0,NULL,NULL}

Key: @1
Value: {&true_var,0,0,NULL,NULL}

Key: a
Value: {&float_var,1,100,{&float_var,0,0,NULL,0x9b71510},NULL}

Key: @2
Value: {&int_var,0,0,NULL,NULL}

Key: @3
Value: {unknown_type,0,0,NULL,NULL}

Intermediate Code:
Op		Arg1		Arg2		Result
OP: +	Symbol: i	Symbol: @2	Symbol: @3	
OP: =	Symbol: @3			Symbol: i	
OP: <	Symbol: a	Symbol: v	Symbol: @4	
OP: -	Symbol: j	Symbol: @5	Symbol: @6	
OP: =	Symbol: @6			Symbol: j	
OP: >	Symbol: a	Symbol: v	Symbol: @7	
OP: >=	Symbol: i	Symbol: j	Symbol: @8	
OP: =	Symbol: a			Symbol: x	
OP: =	Symbol: a			Symbol: a	
OP: =	Symbol: x			Symbol: a
	