This compiler is a project for Case Western Reserve University's 
EECS 337 course (Compiler Design).


The parser is not yet part of the test suite. Not much is, really.
Anyway, compiling the parser is as easy as a 'make -B parser', and
running it is as easy as a './parser'. An example session:

------------------
john@kiwi:~/projects/dragon-compiler(master)$ ./parser 
{int[10][20] foo;}
decls->empty
type-> BASIC
type-> type [ NUM ]
type-> type [ NUM ]
decl-> type ID
decls->decls decl
stmts->empty
block->decls stmts
{break;} 
syntax error
foo;: 134537328
-----------------

Note that entering multiple top level {} statements causes the
parser to barf. I'm not sure why that is, but I guess it's useful
when it actually comes to writing syntactically correct programs.
(but {break;} is accepted by the parser if it is the first {}).
Also, if you encounter a syntax error, you will get a printout of
the symbol table. I just noticed as I made the example session that
somehow I'm including the semi-colon as part of the symbol. I'm
not sure how that happened, but I don't have time to look into it
right now as I have a math test tomorrow that I need to start 
studying for...

On that note, you might notice that I was a bit lazy/busy and did not
print out any info dealing with the data types of symbols. It really
does work though, but you don't have to take my word for it. 
The parser is currently set to compile with debug flags, so
you can drop into gdb and check it out if you want. A breakpoint
at parser.yacc:87 ought to do the job.


Error Handing:
=============
Error handling in this parser is quite simple: don't type it wrong.
The parser isn't gonna give you much info besides "syntax error".
If you're perfect, this isn't a problem, if you aren't perfect,
remember that I'm not either (or I am perfect, but I don't have time
to spare). I'll get around to adding line number error handling
at some point, but at least yacc tells you that you have a problem.
Strategy: Do it right the first time.


TEST PROGRAM:

{
  int i; int j; float v; float x; float[100] a;
  while (true) {
    do i = i+1; while(a[i] < v);
    do j = j-1; while(a[j] > v);
    if(i >= j) break;
    x = a[i]; a[i] = a[j]; a[j] = x;
  }
}


I entered this though, because reading from stdin doesn't like 
newlines:


{int i; int j; float v; float x; float[100] a; while (true) { do i = i+1; while(a[i] < v); do j = j-1; while(a[j] > v); if(i >= j) break; x = a[i]; a[i] = a[j]; a[j] = x;}}


OUTPUT:

decls->empty
type-> BASIC
decl-> type ID
decls->decls decl
type-> BASIC
decl-> type ID
decls->decls decl
type-> BASIC
decl-> type ID
decls->decls decl
type-> BASIC
decl-> type ID
decls->decls decl
type-> BASIC
type-> type [ NUM ]
decl-> type ID
decls->decls decl
stmts->empty
factor->TRUE
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
decls->empty
stmts->empty
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
factor->NUM
urnary->factor
term->urnary
expr->expr + expr
rel->expr
equality->rel
join->equality
bool->join
stmt->loc = bool
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
loc-> loc [ bool ]
factor->loc
urnary->factor
term->urnary
expr->term
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr < expr
equality->rel
join->equality
bool->join
stmt->DO stmt WHILE ( bool ) ;
stmts->stmts stmt
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
factor->NUM
urnary->factor
term->urnary
expr->expr - expr
rel->expr
equality->rel
join->equality
bool->join
stmt->loc = bool
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
loc-> loc [ bool ]
factor->loc
urnary->factor
term->urnary
expr->term
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr > expr
equality->rel
join->equality
bool->join
stmt->DO stmt WHILE ( bool ) ;
stmts->stmts stmt
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr >= expr
equality->rel
join->equality
bool->join
stmt->BREAK ;
stmt->IF ( bool ) stmt
stmts->stmts stmt
loc->ID
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
loc-> loc [ bool ]
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
stmt->loc = bool
stmts->stmts stmt
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
loc-> loc [ bool ]
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
loc-> loc [ bool ]
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
stmt->loc = bool
stmts->stmts stmt
loc->ID
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
loc-> loc [ bool ]
loc->ID
factor->loc
urnary->factor
term->urnary
expr->term
rel->expr
equality->rel
join->equality
bool->join
stmt->loc = bool
stmts->stmts stmt
block->decls stmts
stmt->block
stmt->WHILE ( bool ) stmt
stmts->stmts stmt
block->decls stmts

